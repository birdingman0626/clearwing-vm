package com.thelogicmaster.clearwing;

import com.thelogicmaster.clearwing.bytecode.Instruction;
import com.thelogicmaster.clearwing.bytecode.LabelInstruction;
import com.thelogicmaster.clearwing.bytecode.LineNumberInstruction;
import com.thelogicmaster.clearwing.bytecode.TryInstruction;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;

import java.util.*;
import java.util.function.Function;

public class BytecodeMethod {

	private final BytecodeClass clazz;
	private final String name;
	private final String originalName;
	private final int access;
	private final String desc;
	private final String signature;
	private final MethodSignature methodType;
	private final String[] exceptions;

	private final ArrayList<Instruction> instructions = new ArrayList<>();
	private final ArrayList<BytecodeAnnotation> annotations = new ArrayList<>();
	private int stackSize;
	private int localCount;
	private final HashMap<Label, Integer> labelIds = new HashMap<>();
	private int labelCount;
	private final ArrayList<Location> locations = new ArrayList<>();
	private final ArrayList<ExceptionFrame> exceptionFrames = new ArrayList<>();
	private boolean intrinsic;
	private boolean generated;

	public BytecodeMethod (BytecodeClass clazz, String name, int access, String desc, String signature, String[] exceptions) {
		this.clazz = clazz;
		this.originalName = name;
		this.methodType = new MethodSignature(name, desc, clazz);
		this.access = access;
		this.name = Utils.sanitizeMethod(clazz.getName(), methodType, isStatic());
		this.desc = desc;
		this.signature = signature;
		this.exceptions = exceptions;
	}

	public void addInstruction(Instruction instruction) {
		instructions.add(instruction);
	}

	public boolean isStatic() {
		return (access & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC;
	}

	public boolean isNative() {
		return (access & Opcodes.ACC_NATIVE) == Opcodes.ACC_NATIVE;
	}

	public boolean isAbstract() {
		return (access & Opcodes.ACC_ABSTRACT) == Opcodes.ACC_ABSTRACT;
	}

	public boolean isSynchronized() {
		return (access & Opcodes.ACC_SYNCHRONIZED) == Opcodes.ACC_SYNCHRONIZED;
	}

	public boolean isMain() {
		return isStatic() && (access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC && originalName.equals("main") && "([Ljava/lang/String;)V".equals(desc);
	}

	public boolean hasBody() {
		return !isNative() && !isAbstract();
	}

	public boolean isAnnotationType() {
		return originalName.equals("annotationType") && clazz.isAnnotation();
	}

	/**
	 * Collects and returns all class dependencies (Sanitized class names)
	 */
	public void collectDependencies(Set<String> dependencies, Map<String, BytecodeClass> classMap) {
		for (Instruction instruction: instructions)
			instruction.collectDependencies(dependencies);
		if (methodType.getReturnType().getComponentType() == TypeVariants.OBJECT)
			dependencies.add(methodType.getReturnType().getRegistryTypeName());
		for (JavaType type: methodType.getParamTypes())
			if (type.getComponentType() == TypeVariants.OBJECT)
				dependencies.add(type.getRegistryTypeName());
		for (BytecodeAnnotation annotation: annotations)
			annotation.collectDependencies(dependencies, classMap);
	}

	public void processHierarchy(HashMap<String, BytecodeClass> classMap) {
		for (Instruction instruction: instructions)
			instruction.processHierarchy(classMap);

		for (BytecodeAnnotation annotation : annotations)
			annotation.mergeDefaults(classMap);
	}

	public void resolveSymbols() {
		for (Instruction instruction: instructions)
			instruction.resolveSymbols();
	}
	
	public int getLabelId(Label label) {
		if (label == null)
			return -1;
		if (labelIds.containsKey(label))
			return labelIds.get(label);
		labelIds.put(label, labelCount++);
		return labelIds.get(label);
	}

	/**
	 * Mark this method as intrinsic so that it will not generate the function body
	 */
	public void markIntrinsic() {
		intrinsic = true;
	}

	public boolean isIntrinsic() {
		return intrinsic;
	}

	/**
	 * Mark this method as transpiler generated to avoid unneeded generation
	 */
	public void markGenerated() {
		generated = true;
	}

	/**
	 * Whether this method was generated by the transpiler and doesn't need a stack and such
	 */
	public boolean isGenerated() {
		return generated;
	}

	/**
	 * Finds the first instruction of a given type and returns the index, throwing an exception if one isn't found
	 */
	public <T extends Instruction> int findInstruction(Class<T> clazz) {
		return findInstruction(0, instructions.size(), true, clazz);
	}

	/**
	 * Finds the first instruction of a given type in range [start, end) and returns the index
	 * Throws an exception if one isn't found and required is set
	 */
	public <T extends Instruction> int findInstruction(int start, int end, boolean required, Class<T> clazz) {
		return findInstruction(start, end, required, instr -> clazz.isAssignableFrom(instr.getClass()));
	}

	/**
	 * Finds the first instruction matching the predicate and returns the index, throwing an exception if one isn't found
	 */
	public int findInstruction(Function<Instruction, Boolean> func) {
		return findInstruction(0, instructions.size(), true, func);
	}

	/**
	 * Finds the index of the label instruction corresponding to `label`, throwing an exception if not found
	 */
	public int findLabelInstruction(int label) {
		return findInstruction(instr -> instr instanceof LabelInstruction && ((LabelInstruction) instr).getLabel() == label);
	}

	/**
	 * Finds the first instruction matching the predicate in range [start, end) and returns the index
	 * Throws an exception if one isn't found and required is set
	 */
	public int findInstruction(int start, int end, boolean required, Function<Instruction, Boolean> func) {
		for (int i = start; i < end; i++)
			if (func.apply(instructions.get(i)))
				return i;
		if (required)
			throw new TranspilerException("Failed to find instruction");
		return -1;
	}
	
	public int findLineNumber(int start, int defaultLine) {
		for (int i = start; i >= 0; i--)
			if (instructions.get(i) instanceof LineNumberInstruction lineInst)
				return lineInst.getLine();
		return defaultLine;
	}

	public void addAnnotation(BytecodeAnnotation annotation) {
		annotations.add(annotation);
	}

	public ArrayList<BytecodeAnnotation> getAnnotations() {
		return annotations;
	}

	public boolean isFinalizer() {
		return "M_finalize".equals(name);
	}

	public boolean isStaticInitializer() {
		return originalName.equals("<clinit>");
	}

	public boolean isConstructor() {
		return originalName.equals("<init>");
	}

	public boolean isPublic() {
		return (access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC;
	}

	public BytecodeClass getOwner () {
		return clazz;
	}

	public String getName () {
		return name;
	}

	public String getOriginalName () {
		return originalName;
	}

	public int getAccess () {
		return access;
	}

	public String getDesc () {
		return desc;
	}

	public String getGenericSignature() {
		return signature;
	}

	public String[] getExceptions () {
		return exceptions;
	}

	public List<Instruction> getInstructions () {
		return instructions;
	}

	public void setStackSize(int stackSize, int localCount) {
		this.stackSize = stackSize;
		this.localCount = localCount;
	}

	public int getStackSize() {
		return stackSize;
	}

	public int getLocalCount() {
		return localCount;
	}

	public void addTryCatch(Label start, Label end, Label handler, String type) {
		exceptionFrames.add(new ExceptionFrame(type, getLabelId(start), getLabelId(end), getLabelId(handler), exceptionFrames.size()));
	}
	
	public Location addLocation(int line) {
		Location location = new Location(line, locations.size());
		locations.add(location);
		return location;
	}

	public ArrayList<ExceptionFrame> getExceptionFrames() {
		return exceptionFrames;
	}

	public ArrayList<Location> getLocations() {
		return locations;
	}

	public MethodSignature getSignature() {
		return methodType;
	}

	@Override
	public String toString() {
		return clazz + "." + name;
	}

	@Override
	public int hashCode() {
		return signature.hashCode();
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof BytecodeMethod))
			return false;
		return ((BytecodeMethod) obj).methodType.equals(methodType);
	}

	public static class ExceptionFrame {
		private final String type;
		private final String qualifiedType;
		private final int startLabel;
		private final int endLabel;
		private final int handlerLabel;
		private final int index;
		private int startLocation;
		private int endLocation;
		
		public ExceptionFrame(String type, int start, int end, int handler, int index) {
			this.type = type;
			this.qualifiedType = type == null ? null : Utils.getQualifiedClassName(type);
			this.startLabel = start;
			this.endLabel = end;
			this.handlerLabel = handler;
			this.index = index;
		}

		public String getType() {
			return type;
		}

		public String getQualifiedType() {
			return qualifiedType;
		}
		
		public int getStartLabel() {
			return startLabel;
		}

		public int getEndLabel() {
			return endLabel;
		}
		
		public int getHandlerLabel() {
			return handlerLabel;
		}

		public int getIndex() {
			return index;
		}

		public void setStartLocation(int startLocation) {
			this.startLocation = startLocation;
		}

		public void setEndLocation(int endLocation) {
			this.endLocation = endLocation;
		}

		public int getStartLocation() {
			return startLocation;
		}

		public int getEndLocation() {
			return endLocation;
		}
		
		public void build(StringBuilder builder) {
			builder.append("{ ").append(startLocation).append(", ").append(endLocation).append(", ")
					.append(type == null ? "nullptr" : "&class_" + qualifiedType).append(" }");
		}
	}
	
	public static class Location {
		private final int line;
		private final int index;

		public Location(int line, int index) {
			this.line = line;
			this.index = index;
		}
		
		public int getLine() { 
			return line; 
		}
		
		public int getIndex() {
			return index;
		}
		
		public void build(StringBuilder builder) {
			builder.append("{ ").append(line).append(" }");
		}
	}
}
